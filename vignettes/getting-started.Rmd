---
title: "Getting Started with shortestpath"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{knitr,shortestpath}
---
```{r, echo =FALSE, message=FALSE}
library(shortestpath)
library(igraph)
library(knitr)
set.seed(22)
```

##Intro
The shortestpath package provides functions to solve the shortest path problem by using the Dijkstra-, Floyd-Warshall, A*Search and Bellman-Ford algorithm. Additionally, the package offers 
the tabular and graphical visualization of the shortest path optimization steps. 

## Create a Graph
As a first step the function randomGraph() can be used in order to create a undirected graph "g" with positive edge weights. 
```{r}
g <- make_ring(4) %>%
    set_edge_attr("weight", value = c(2,2,3,1) ) %>%
    as.spgraph()
```
The parameter "4" indicates the number of vertices of the generated graph.

## Dijkstra algorithm 
Use the Dijkstra algrithm to find the shortest path between the two vertices "A" and "C" in the graph "g".
```{r}
d <- dijkstra(g, "A", "C")
```
The variable "d" contains a list of igraphs. These igraphs have additional attributes and are therefore called shortest path graphs (spgraphs). Each spgraph represents one optimization step of the Dijkstra algorithm.

## Plot 
Use the normal plot function to print all the steps of the Dijkstra algorithm. 
```{r,fig.width=7, fig.height=6}
par(mar=c(0,0,0,0),mfrow = c(2, 2))
plot(d)
```
A detailed explanation of the single optimization steps can be read in the processing vignette.  

<br> 
Additionally, the minimum distance table can be printed by calling the attribute "min_dists" of each spgraph.
```{r}
 for(step in d){ 
   print(step$min_dists)
   cat("\n")
   }
```
